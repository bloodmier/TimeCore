
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import puppeteer from "puppeteer";
import crypto from "node:crypto";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// --- Translate ---
const TEXTS = {
  sv: {
    docTitle: (inv) => `Arbetsrapport för faktura ${inv}`,
    summaryByPerson: "Summering per person",
    perCategory: "Per kategori",
    none: "Inga rader",
    person: "Person",
    hours: "Timmar",
    date: "Datum",
    description: "Beskrivning",
    total: "Totalt",
    unknown: "Okänd",
    unknownCategory: "Okänd",
    generatedBy: "Genererad automatiskt av DB Intra",
    hoursSuffix: "h",
    htmlLang: "sv",
  },
  en: {
    docTitle: (inv) => `Worklog for invoice ${inv}`,
    summaryByPerson: "Summary by person",
    perCategory: "By category",
    none: "No rows",
    person: "Person",
    hours: "Hours",
    date: "Date",
    description: "Description",
    total: "Total",
    unknown: "Unknown",
    unknownCategory: "Unknown",
    generatedBy: "Automatically generated by DB Intra",
    hoursSuffix: "h",
    htmlLang: "en",
  },
};

const nf = (lang) => new Intl.NumberFormat(lang);
const df = (lang) => new Intl.DateTimeFormat(lang, { year: "numeric", month: "2-digit", day: "2-digit" });

export async function renderWorklogPdf({ invoiceNo, customer, rows, lang = "sv", period }) {
  const L = (lang === "en") ? "en" : "sv";
  const T = TEXTS[L];

  const logoPath = path.resolve(__dirname, "../../img/TimeCore.png");
  let logoBase64 = null;
  try { logoBase64 = fs.readFileSync(logoPath, "base64"); } catch {}

  // ---- Aggregat ----
  const totalHours = rows.reduce((s, r) => s + (Number(r.hours) || 0), 0);

  // per person
  const byPerson = rows.reduce((acc, r) => {
    const key = r.by || T.unknown;
    acc[key] = (acc[key] ?? 0) + (Number(r.hours) || 0);
    return acc;
  }, {});

  // per category
  const byCategory = rows.reduce((acc, r) => {
    const key = r.category || T.unknownCategory;
    (acc[key] ??= { hours: 0, items: [] });
    acc[key].hours += Number(r.hours) || 0;
    acc[key].items.push(r);
    return acc;
  }, {});

  const peopleRowsHtml = Object.entries(byPerson)
    .sort((a, b) => b[1] - a[1])
    .map(([name, h]) => `
      <tr>
        <td>${name}</td>
        <td class="num">${nf(L).format(h)}</td>
      </tr>
    `).join("");

  const categoriesHtml = Object.entries(byCategory)
    .sort((a, b) => b[1].hours - a[1].hours)
    .map(([cat, info]) => {
      const itemsHtml = info.items.map(r => `
        <tr>
          <td style="width: 16%">${r.date ? df(L).format(new Date(r.date)) : ""}</td>
          <td>${r.desc ?? ""}</td>
          <td style="width: 24%">${r.by ?? ""}</td>
          <td class="num" style="width: 12%">${nf(L).format(r.hours)}</td>
        </tr>
      `).join("");

      return `
        <div class="section">
          <h3 class="section-title"><span>${cat}</span><span class="section-hours">${nf(L).format(info.hours)} ${T.hoursSuffix}</span></h3>
          <table class="table">
            <thead>
              <tr>
                <th>${T.date}</th>
                <th>${T.description}</th>
                <th>${T.person}</th>
                <th class="num">${T.hours}</th>
              </tr>
            </thead>
            <tbody>
              ${itemsHtml}
            </tbody>
          </table>
        </div>
      `;
    }).join("");

  const periodLabel =
    period?.from && period?.to
      ? `${df(L).format(new Date(period.from))} – ${df(L).format(new Date(period.to))}`
      : "";

  const html = `
  <html lang="${T.htmlLang}">
  <head>
    <meta charset="utf-8"/>
    <style>
      :root{
        --fg:#111;
        --muted:#555;
        --border:#e6e6e6;
        --bg-alt:#fafafa;
        --accent:#0b6efd;
        --space:12px;
      }
      *{ box-sizing:border-box; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
      html,body{ margin:0; padding:0; }
      body{
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
        color:var(--fg);
        margin:24px;
        line-height:1.35;
        font-size:12.5px;
      }
      .header{
        display:flex; align-items:center; justify-content:space-between; gap:20px;
        padding-bottom:12px; border-bottom:2px solid #000; margin-bottom:20px;
      }
      .logo{ width:200px; height:auto; object-fit:contain; }
      .header-info{ flex:1; text-align:right; }
      h1{ font-size:18px; margin:0; letter-spacing:.2px; }
      h2{ font-size:15px; margin:18px 0 8px; }
      h3{ margin:0; }
      .meta{ color:var(--muted); margin-top:4px; font-size:12.5px; }

      .grid{ display:grid; grid-template-columns: 1fr; gap:16px; }
      .card{ border:1px solid var(--border); border-radius:8px; padding:12px 12px 8px; background:#fff; }

      .table{ width:100%; border-collapse:separate; border-spacing:0; font-size:12px; margin-top:8px; border:1px solid var(--border); border-radius:8px; overflow:hidden; }
      .table thead th{ background:#f6f6f6; text-align:left; padding:8px 10px; font-weight:600; border-bottom:1px solid var(--border); text-transform:uppercase; letter-spacing:.4px; font-size:11.5px; color:#333; }
      .table tbody td{ padding:8px 10px; border-bottom:1px solid var(--border); vertical-align:top; }
      .table tbody tr:nth-child(odd){ background:var(--bg-alt); }
      .table tbody tr:last-child td{ border-bottom:none; }

      .num{ text-align:right; white-space:nowrap; }

      .totals{ margin-top:6px; font-weight:700; display:inline-block; padding:4px 8px; border:1px solid var(--border); border-radius:999px; background:#fff; }

      .section{ page-break-inside:avoid; margin:14px 0 10px; }
      .section-title{ display:flex; align-items:center; justify-content:space-between; font-size:13.5px; font-weight:700; margin:0 0 6px; padding-left:10px; border-left:3px solid var(--accent); }
      .section-hours{ font-weight:700; font-size:12.5px; color:#000; background:#eef5ff; border:1px solid #d9e8ff; border-radius:6px; padding:2px 8px; margin-left:10px; }

      .footer{ margin-top:25px; font-size:11px; color:#999; text-align:right; }

      table, thead, tbody, tr, td, th { page-break-inside: avoid !important; }
      .section { break-inside: avoid; }
    </style>
  </head>
  <body>
    <div class="header">
      ${logoBase64 ? `<img src="data:image/png;base64,${logoBase64}" class="logo" />` : ""}
      <div class="header-info">
        <h1>${T.docTitle(invoiceNo || "-")}</h1>
        <p class="meta">${customer || T.unknown}${periodLabel ? " • " + periodLabel : ""}</p>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2>${T.summaryByPerson}</h2>
        <table class="table">
          <thead>
            <tr><th>${T.person}</th><th class="num">${T.hours}</th></tr>
          </thead>
          <tbody>
            ${peopleRowsHtml || `<tr><td colspan="2">${T.none}</td></tr>`}
          </tbody>
        </table>
        <div class="totals">${T.total}: ${nf(L).format(totalHours)} ${T.hoursSuffix}</div>
      </div>
    </div>

    <h2 style="margin-top:18px;">${T.perCategory}</h2>
    ${categoriesHtml || `<p>${T.none}</p>`}

    <div class="footer">${T.generatedBy} – ${df(L).format(new Date())}</div>
  </body>
  </html>
  `;

  const browser = await puppeteer.launch({
  executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || "/usr/bin/chromium",
  args: ["--no-sandbox", "--disable-setuid-sandbox"],
});

  const page = await browser.newPage();
  await page.setContent(html, { waitUntil: "networkidle0" });
  const pdfBuffer = await page.pdf({
    format: "A4",
    printBackground: true,
    margin: { top: "12mm", right: "12mm", bottom: "12mm", left: "12mm" },
  });
  await browser.close();

  const sha256_hex = crypto.createHash("sha256").update(pdfBuffer).digest("hex");
  return { buffer: pdfBuffer, sha256_hex };
}
